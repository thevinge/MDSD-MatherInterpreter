/*
 * generated by Xtext 2.20.0
 */
package org.xtext.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import javax.swing.JOptionPane
import org.xtext.mdsd.mathinterpreter.MathExp
import org.xtext.mdsd.mathinterpreter.Plus
import org.xtext.mdsd.mathinterpreter.Num
import org.xtext.mdsd.mathinterpreter.Minus
import org.xtext.mdsd.mathinterpreter.Mult
import org.xtext.mdsd.mathinterpreter.Divi
import org.xtext.mdsd.mathinterpreter.varBindUse
import java.util.Map
import java.util.HashMap

import java.util.Iterator
import org.xtext.mdsd.mathinterpreter.Expression
import org.xtext.mdsd.mathinterpreter.VarBind

//import org.xtext.mdsd.mathinterpreter.Primary

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathinterpreterGenerator extends AbstractGenerator {

	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		System.out.println("Math expression = "+math.display)
		// For +1 score, replace with hovering, see Bettini Chapter 8
		JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def int compute(MathExp math) { 
		val bindings = new HashMap<String, Integer>()
		math.exp.computeExp(bindings)
		
	}
	
	def int computeExp(Expression exp, HashMap<String, Integer> bindings) {
		switch (exp){
			Num: exp.value
			Plus: (exp.left.computeExp(bindings)) + (exp.right.computeExp(bindings))
			Minus: (exp.left.computeExp(bindings)) - (exp.right.computeExp(bindings))
			Mult: (exp.left.computeExp(bindings)) * (exp.right.computeExp(bindings))
			Divi: (exp.left.computeExp(bindings)) / (exp.right.computeExp(bindings))
			varBindUse: bindings.get(exp.varName)
			VarBind: exp.body.computeExp(bindings.Update(exp.varName, exp.bindingValue.computeExp(bindings)))
		}
	}
	
	def HashMap<String, Integer> Update(HashMap<String, Integer> old, String key, int value){
		val updatedBindings = new HashMap<String, Integer>(old)
		updatedBindings.put(key,value)
		updatedBindings
	}
	

	//
	// Display function: show complete syntax tree
	// Note: written according to illegal left-recursive grammar, requires fix
	//

	def CharSequence display(MathExp math) '''Math[«math.exp.displayExp»]'''
	def CharSequence displayExp(Expression exp) {
		'('+
		switch (exp){
			Num: exp.value
			Plus: '''«(exp.left.displayExp)» + «(exp.right.displayExp)»'''
			Minus: '''«(exp.left.displayExp)» - «(exp.right.displayExp)»'''
			Mult: '''«(exp.left.displayExp)» * «(exp.right.displayExp)»'''
			Divi: '''«(exp.left.displayExp)» / «(exp.right.displayExp)»'''
			varBindUse: exp.varName
			VarBind: '''let «exp.varName» = «exp.bindingValue» in «exp.body.displayExp»;'''
		}
		+ ')'
	}
	
	
	
	
	
}
